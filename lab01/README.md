# Лабораторная работа. Численное решение уравнения переноса с использованием параллельных алгоритмов.

В данной работе мы рассмотрим численное решение уравнения переноса (дифференциальное уравнение
в частных производных). А так же сравним алгоритмы численного решения для однопоточной и
многопоточной програм.

## Теория

В данной работе будем решать дифференциальное уравнение

$$
\begin{cases}
\frac{\partial u}{\partial t} + \frac{\partial u}{\partial t} = x + t \\
u(0, x) = \phi(x) = \cos{\pi x} \\
u(t, 0) = \psi(t) = e^{-t}
\end{cases}
$$

Програмно в однопоточной и многопоточной программе реализованы 3 расчетные схемы:
- явный левый уголок
- четырехточечная схема
- крест

Приведем разностную формулу для расчетной схемы "крест"

$$
x = x = x = x 
$$

## Инструкция к запуску

- images -- папка с картинками (графики и результаты исследования)
    - validation -- в данной папке хранятся 3d графики решения уравнения переноса. На одном графике построено решение, полученное в результате работы последовательной программы и решение, полученное в результате работы параллельной программы. Сделано это для того, чтобы показать, что обычная и параллельная программа дают верное решение задачи. Присутствуют решения для разных сеток.
    - acceleration -- в данной папке хранятся результаты сравнения времени работы обычной и параллельной програм.
- python -- в данной папке хранятся python скрипты для запуска эксперементов и построения сравнительных графиков. __Внимание__, в каждом python скрипте идет вызов c++ программы (обычной или параллельной).
- Makefile
- Consistent.cpp -- обычная (однопоточная) программа численного решения уравнения переноса.
- main.cpp -- параллельная программа численного решения уравнения переноса.
- PreWork.cpp -- допуск к лабораторной работе.

Собрать обе программы (Consistent.cpp и main.cpp) можно командой
```
make
```

### Допуск
Запуск программы "допуск"
```
mpiexec -n 2 ./prework 10000000
```

В качестве допуска к лабораторной работе необходимо было измерить время, затрачиваемое на
одну посылку (время отработки одного Send). Поскольку в самой работе мы будем пересылать числа
с плавающей точкой, то замеряем посылку одного числа double. Программа производит N посылок и
замеряет время, а затем делит измеренное время на количество посылок, получая таким образом
время одной посылки. (В аргументе командной строки программы, как раз передаем количество 
запусков).

Для автоматизации в папке __python__ создан дополнительный скрипт _OneSendTimeMeasure.py_.
Данный скрипт автоматически запускает программу на разных значениях N. Таким образом, при 
увеличении N значение, выводимое программой выйдет на горизонтальную ассимптоту, значение
которой и даст нам примерное время работы одного Send.

__В результате эксперементов было установлено, что операция одной отправки занимает порядка 1 мкс.__

__ATTENTION:__ при очередном запуске программы не забывайте удалить из рабочей дериктории .txt
файлы со старыми результатами.

### Основная программа
Запуск однопоточной программы
```
./a.out 1000 1000
```
Запуск многопоточной программы
```
mpiexec -n 4 ./main 1000 1000
```

Через аргументы командной строки мы задаем количество точек на временном и пространственном 
диапазонах соответственно.
__ATTENTION:__ в силу ~~корявой~~ реализации программы вам необходимо убедиться, что количество 
точек на пространственном и временном диапазонах делится на цело на количество процессов (при 
параллельном запуске).

В результате работы любой программы мы получаем численное решение уравнение переноса, а так же 
время работы программы (оно необходимо для исследования ускорения параллельной программы). 
Однопоточная программа записывает численное решение в файл _validate.txt_, параллельная программа
записывает решение в файл _data.txt_. Обе программы пишут свое время работы в файл _time.txt_.

__ATTENTION:__ при очередном запуске программы не забывайте удалить из рабочей дериктории .txt
файлы со старыми результатами.

#### Python скрипты

В папке _python_ вы можете найти 3 python программы.

Программа _ViewResult.py_ выводит 3d график решения уравнения переноса и позволяет интерактивно 
исследовать его. Данная программа работает с заранее полученным численным решением, поэтому 
получите файл с численным решением _data.txt_ или _validation.txt_ заранее.

```
make
./a.out 100 100
mpiexec -n 2 ./main 1000 1000
cd python
pytohn3 ViewResult.py -d ../validate.txt
pytohn3 ViewResult.py -d ../data.txt
```

После закрытия интерактивного графика, он сохранится в папке _images_ с именем _solution.jpg_.

Программа _CheckValidation.py_ запускает однопоточную и многопотоную программу на разных сетках,
а затем строит на одном графике решения, полученные в результате работы этих программ. Скрипт 
служет для сравнения решений. Картинки с графиками будут сохранены в _/images/validation/_
Поскольку скрипт самостоятельно запускает c++ программы, не нужно запускать их заранее. Однако
обе программы должны быть скомпилированы в рабочей дериктории.

```
make
cd python
python3 CheckValidation.py
```

__ATTENTION:__ после того, как скрипт отработает, не забудьте удалить из дериктории _python_ все
.txt файлы.

Программа _Experiment1.py_ запускает однопоточную и многопоточную программы на заданном числе 
потоков и на разных сетках и строит график зависимости времени их работы от количества точек на сетке. В аргументы данного скрипта необходимо передать количество потоков, на котором будет 
запускаться параллельная программа. Картинки с графиками будут сохранены в 
_/images/acceleration/_. Поскольку скрипт самостоятельно запускает c++ программы, не нужно запускать их заранее. Однако обе программы должны быть скомпилированы в рабочей дериктории.

```
make
cd python
python3 Experiment1.py -n 4
```

__ATTENTION:__ после того, как скрипт отработает, не забудьте удалить из дериктории _python_ все
.txt файлы.

Программа _Experiment2.py_ запускает однопоточную и многопоточную программу на разном количестве 
процессов на одной сетке и строит график зависимости отношения времени работы однопоточной и 
многопоточной програм от количества процессов. Картинки с графиками будут сохранены в 
_/images/acceleration/_. Поскольку скрипт самостоятельно запускает c++ программы, не нужно запускать их заранее. Однако обе программы должны быть скомпилированы в рабочей дериктории.

```
make
cd python
python3 Experiment2.py
```

__ATTENTION:__ после того, как скрипт отработает, не забудьте удалить из дериктории _python_ все
.txt файлы.

##  Результаты исследования

<p align="center">
<img src="https://github.com/pavel-collab/ParProgMIPT/blob/main/lab01/images/validation/result.jpg" alt="caption" width="300"/>
</p>

В процессе тестирования производилось сравнение времени работы однопоточной программы и 
многопоточной программы с различным количеством параллельных процессов на разных расчетных 
сетках.

Для наглядности, рассмотрим графики зависимости времени работы однопоточной и многопоточной 
програм от количества точек на расчетной сетке (приведено количество точек по одной оси) при
фиксированном количестве процессов.

#### Время работы на двух параллельных процессах

<p align="center">
<img src="https://github.com/pavel-collab/ParProgMIPT/blob/main/lab01/images/acceleration/2_proc_13.04.2023-14.22.18.jpg" alt="caption" width="300"/>
</p>

#### Время работы на четырех параллельных процессах

<p align="center">
<img src="https://github.com/pavel-collab/ParProgMIPT/blob/main/lab01/images/acceleration/4_proc_13.04.2023-17.24.18.jpg" alt="caption" width="300"/>
</p>

#### Время работы на пяти параллельных процессах

<p align="center">
<img src="https://github.com/pavel-collab/ParProgMIPT/blob/main/lab01/images/acceleration/5_proc_13.04.2023-19.42.21.jpg" alt="caption" width="300"/>
</p>

#### Время работы на восьми параллельных процессах

<p align="center">
<img src="https://github.com/pavel-collab/ParProgMIPT/blob/main/lab01/images/acceleration/8_proc_13.04.2023-20.30.13.jpg" alt="caption" width="300"/>
</p>

### Вывод

Как видно из графиков, на малых расчетных сетках однопоточная и многопоточная программа выдают
примерно одинаковый (в пределах погрешности) результат. На самом деле (на графиках это плохо 
видно) на малых расчетных сетках однопоточная программа показывает лучший результат, так как
в случае многопоточной программы время, затраченное на создание и поддержание работы 
параллельных процессов, а так же на передачу данных между процессами не окупается скоростью 
вычислений.

На больших расчетных сетках явное преимущество на стороне параллельной программы. 
Распараллеливание дает заметный прирост к скорости работы программы. Начиная, примерно с 8-10к 
точек на сетке (на оси) ускорение параллельной программы > 1. 

Как видно из графиков, во многих тестах на 16000 точек происходит скачек времени работы 
программы, причем, как в случае однопоточной, так и в случае многопоточной программы (в случае
многопоточной скачек выражен не так сильно). Причины не установлены.